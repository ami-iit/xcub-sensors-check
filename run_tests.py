# Description: This script is used to run the tests associated to the xcub_sensor_check package.
# Author: Giulio Romualdi
# License: BSD 3-clause

from pathlib import Path
import argparse
import bipedal_locomotion_framework as blf
import xcub_sensor_check
from typing import Dict, List
import resolve_robotics_uri_py


def generate_test_list(config_file: Path, output_folder: Path):
    param_handler = blf.parameters_handler.TomlParametersHandler()
    param_handler.set_from_file(str(config_file))

    test_list = []

    try:
        tests_name_list = param_handler.get_parameter_vector_string("test_list")
    except:
        tests_name_list = []

    # Get common parameters
    model_absolute_path = resolve_robotics_uri_py.resolve_robotics_uri(
        param_handler.get_parameter_string("model_package_path")
    )
    dataset_relative_path = param_handler.get_parameter_string("dataset_path")

    compute_joint_velocity_from_position = param_handler.get_parameter_bool(
        "compute_joint_velocity_from_position"
    )
    compute_joint_acceleration_from_position = param_handler.get_parameter_bool(
        "compute_joint_acceleration_from_position"
    )

    velocity_window_length = 0
    if compute_joint_velocity_from_position:
        velocity_window_length = param_handler.get_parameter_int(
            "velocity_svg_window_length"
        )

        blf.log().info(
            f"Computing joint velocity from position using a window length of {velocity_window_length}"
        )

    acceleration_window_length = 0
    if compute_joint_acceleration_from_position:
        acceleration_window_length = param_handler.get_parameter_int(
            "acceleration_svg_window_length"
        )
        blf.log().info(
            f"Computing joint acceleration from position using a window length of {acceleration_window_length}"
        )

    for test_name in tests_name_list:
        test_group = param_handler.get_group(test_name)
        test_group.set_parameter_string("model_path", str(model_absolute_path))
        test_group.set_parameter_string("dataset_file_name", dataset_relative_path)
        test_group.set_parameter_bool(
            "compute_joint_velocity_from_position", compute_joint_velocity_from_position
        )
        test_group.set_parameter_int(
            "velocity_svg_window_length", velocity_window_length
        )
        test_group.set_parameter_bool(
            "compute_joint_acceleration_from_position",
            compute_joint_acceleration_from_position,
        )
        test_group.set_parameter_int(
            "acceleration_svg_window_length", acceleration_window_length
        )

        test_type = getattr(xcub_sensor_check, test_group.get_parameter_string("type"))
        test = test_type(test_name, output_folder)

        test.configure(test_group)
        test_list.append(test)

    return test_list


def print_outcomes(test_list: List[xcub_sensor_check.generic_test.GenericTest]):
    print("ðŸ“Š Test outcomes:")
    if not test_list:
        print("ðŸ˜” No tests were found!")
        return

    for test in test_list:
        emoji = "ðŸŸ¢" if test.outcome else "ðŸ”´"
        outcome = "Passed" if test.outcome else "Failed"
        if test.name != test_list[-1].name:
            print(f"â”œâ”€â”€ {emoji} Test {test.name}: {outcome}")
        else:
            print(f"â””â”€â”€ {emoji} Test {test.name}: {outcome}")


def main():
    parser = argparse.ArgumentParser(description="Run the tests associated to the .")
    parser.add_argument(
        "--config_file",
        "-c",
        type=lambda p: Path(p).absolute(),
        required=True,
        help="Path to the configuration file containing all the name of the tests.",
    )
    parser.add_argument(
        "--output",
        "-o",
        type=lambda p: Path(p).absolute(),
        default=Path.cwd(),
        required=False,
        help="Path where the file generated by the tests will be saved.",
    )
    args = parser.parse_args()

    test_list = generate_test_list(
        config_file=args.config_file, output_folder=args.output
    )

    print(f"ðŸ§ª Running {len(test_list)} tests...")
    for test in test_list:
        if test.name != test_list[-1].name:
            print(f"â”œâ”€â”€ Running test {test.name}...")
        else:
            print(f"â””â”€â”€ Running test {test.name}...")
        test.outcome = test.run()

    # print an empty line
    print()

    print_outcomes(test_list)


if __name__ == "__main__":
    main()
